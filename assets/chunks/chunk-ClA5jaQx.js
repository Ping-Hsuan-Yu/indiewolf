import{g as D,c as g,d as c,b as y,i as d,a as o}from"./chunk-BBqBf8hj.js";function P(){return typeof window<"u"&&typeof window.scrollY=="number"}const I=D("utils/assertRouterType.ts",{});function Y(){J(G()),I.isClientRouting=!0}function G(){return I.isClientRouting!==!1}function J(t){g(P(),`${c.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),y(t,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function V(t){return t instanceof Function||typeof t=="function"}function m(t){return Array.isArray(t)}function q(t){return m(t)&&t.every(e=>typeof e=="string")}function K(t){return d(t)&&Object.values(t).every(e=>typeof e=="string")}function Q(t,e,n){if(!d(t))return!1;if(!(e in t))return n==="undefined";if(n===void 0)return!0;const r=t[e];return n==="undefined"?r===void 0:n==="array"?m(r):n==="object"?d(r):n==="string[]"?q(r):n==="string{}"?K(r):n==="function"?V(r):m(n)?typeof r=="string"&&n.includes(r):n==="null"?r===null:n==="true"?r===!0:n==="false"?r===!1:typeof r===n}function x(t,e,n){e&&(o(!("_isPageContextObject"in e)),Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)))}function S(t,e,n){return typeof t=="string"?$(t.split(""),e,n).join(""):$(t,e,n)}function $(t,e,n){const r=[];let i=e>=0?e:t.length+e;o(i>=0&&i<=t.length);let s=n>=0?n:t.length+n;for(o(s>=0&&s<=t.length);!(i===s||(i===t.length&&(i=0),i===s));){const a=t[i];o(a!==void 0),r.push(a),i++}return r}function mt(t,e){o(ot(t),t),o(e.startsWith("/"));const{hashString:n,withoutHash:r}=X(t);o(n===null||n.startsWith("#"));const i=n===null?"":B(n.slice(1)),{searchString:s,withoutSearch:a}=A(r);o(s===null||s.startsWith("?"));let l="";if(s!==null)l=s;else if(t.startsWith("#")){const u=k();l=u&&A(u).searchString||""}const w={},p={};Array.from(new URLSearchParams(l)).forEach(([u,j])=>{w[u]=j,p[u]=[...p.hasOwnProperty(u)?p[u]:[],j]});let{protocol:R,origin:f,pathnameAbsoluteWithBase:T}=tt(a,e);const U=a.slice((f||"").length);st(t,f,U,s,n);let{pathname:h,isBaseMissing:M}=rt(T,e);const N=C(f,h,s,n),F=f?f.slice(R.length):null,{hostname:L,port:z}=nt(F,t);return h=Z(h),o(h.startsWith("/")),{href:N,protocol:R,hostname:L,port:z,origin:f,pathname:h,pathnameOriginal:U,isBaseMissing:M,search:w,searchAll:p,searchOriginal:s,hash:i,hashOriginal:n}}function X(t){const[e,...n]=t.split("#");return{hashString:["",...n].join("#")||null,withoutHash:e}}function A(t){const[e,...n]=t.split("?");return{searchString:["",...n].join("?")||null,withoutSearch:e}}function B(t){try{return decodeURIComponent(t)}catch{}try{return decodeURI(t)}catch{}return t}function Z(t){return t=t.replace(/\s+$/,""),t=t.split("/").map(e=>B(e).split("/").join("%2F")).join("/"),t}function tt(t,e){o(!t.includes("?")&&!t.includes("#"));{const{protocol:n,origin:r,pathname:i}=O(t);if(r)return{protocol:n,origin:r,pathnameAbsoluteWithBase:i};o(i===t)}if(t.startsWith("/"))return{protocol:null,origin:null,pathnameAbsoluteWithBase:t};{const n=k();let r;return n?r=O(n.split("?")[0].split("#")[0]).pathname:r=e,{protocol:null,origin:null,pathnameAbsoluteWithBase:et(t,r)}}}function k(){return typeof window<"u"?window?.document?.baseURI:void 0}function O(t){if(W(t)){const{protocol:e,uriWithoutProtocol:n}=b(t);o(e);const[r,...i]=n.split("/"),s=e+r;return{pathname:"/"+i.join("/"),origin:s,protocol:e}}else return{pathname:t,origin:null,protocol:null}}function nt(t,e){const n={hostname:null,port:null};if(!t)return n;const r=t.split(":");if(r.length>1){const i=parseInt(r.pop(),10);o(i||i===0,e),n.port=i}return n.hostname=r.join(":"),n}function b(t){const e=":",[n,...r]=t.split(e);if(r.length===0||!/^[a-z][a-z0-9\+\-]*$/i.test(n))return{protocol:null,uriWithoutProtocol:t};let i=n+e,s=r.join(e);const a="//";return s.startsWith(a)&&(i=i+a,s=s.slice(a.length)),{protocol:i,uriWithoutProtocol:s}}function E(t){return["ipfs://","ipns://"].includes(t)?!1:t.endsWith("://")}function et(t,e){const n=e.split("/"),r=t.split("/");let i=e.endsWith("/");t.startsWith(".")&&n.pop();for(const a in r){const l=r[a];l==""&&a==="0"||l!="."&&(l==".."?n.pop():(i=!1,n.push(l)))}let s=n.join("/");return i&&!s.endsWith("/")&&(s+="/"),s.startsWith("/")||(s="/"+s),s}function rt(t,e){o(t.startsWith("/")),o(it(e));let n=t;if(o(n.startsWith("/")),o(e.startsWith("/")),e==="/")return{pathname:t,isBaseMissing:!1};let r=e;return e.endsWith("/")&&n===S(e,0,-1)&&(r=S(e,0,-1),o(n===r)),n.startsWith(r)?(o(n.startsWith("/")||n.startsWith("http")),o(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),o(n.startsWith("/")),{pathname:n,isBaseMissing:!1}):{pathname:t,isBaseMissing:!0}}function it(t){return t.startsWith("/")}function st(t,e,n,r,i){const s=C(e,n,r,i);o(t===s)}function C(t,e,n,r){return`${t||""}${e}${n||""}${r||""}`}function ot(t){return W(t)||t.startsWith("/")||_(t)}function at(t){return t.startsWith("/")||ct(t)||W(t)}function _(t){return[".","?","#"].some(e=>t.startsWith(e))||t===""}function bt(t){return!t.startsWith("/")&&!_(t)}function W(t){const{protocol:e}=b(t);return!!e&&E(e)}function ct(t){const{protocol:e}=b(t);return!!e&&!E(t)}function Wt(t,e){v(t,e)}function lt(t,e,n){v(t,e,{isRedirectTarget:!0})}function v(t,e,{isRedirectTarget:n}={}){if(t.startsWith("/"))return;let r=`${e} is ${c.string(t)} but it should start with ${c.string("/")}`;if(n){if(at(t))return;if(r+=` or a protocol (${c.string("http://")}, ${c.string("mailto:")}, ...)`,n==="unresolved"){if(t==="*")return;r+=`, or be ${c.string("*")}`}}g(!1,r)}function ut(t,e,n=r=>r){if(o(t.length>0),t.length===1)return n(t[0]);const r=t.slice(0,t.length-1),i=t[t.length-1];return r.map(n).join(", ")+`, ${e} `+n(i)}P()&&Y();function wt(t,e){const n="throw redirect()";lt(t,gt(n));const r=[JSON.stringify(t)];e?(ht(e,[301,302],"redirect"),r.push(String(e))):e=302;const i={};return x(i,{_abortCaller:n,_abortCall:`redirect(${r.join(", ")})`,_urlRedirect:{url:t,statusCode:e}}),ft(i)}function ft(t){const e=new Error("AbortRender");return x(e,{_pageContextAbort:t,[H]:!0}),e}const H="_isAbortError";function Rt(t){return typeof t=="object"&&t!==null&&H in t}function Ut(t){return t._urlRewrite||t._urlRedirect||t.abortStatusCode?(o(Q(t,"_abortCall","string")),!0):!1}function ht(t,e,n){const r=ut(e.map(i=>i.toString()),"or");y(e.includes(t),`Unepexected status code ${t} passed to ${n}(), we recommend ${r} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${t} should be added.)`,{onlyOnce:!0})}function jt(t){pt(t);const e={_urlRewrite:null};return t.forEach(n=>{Object.assign(e,n)}),e}function pt(t){const e=[];t.forEach(n=>{const r=n._urlRewrite;{const i=e.indexOf(r);if(i!==-1){const s=[...e.slice(i),r].map(a=>`render('${a}')`).join(" => ");g(!1,`Infinite loop of render() calls: ${s}`)}}e.push(r)})}function St(t,e){const n=[t>0&&c.cyan("throw render('/some-url')"),e>0&&c.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");g(t+e<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}function gt(t){return`URL passed to ${c.code(t)}`}export{ft as A,P as a,Y as b,m as c,Ut as d,it as e,bt as f,ot as g,Q as h,V as i,ut as j,Wt as k,St as l,jt as m,Rt as n,x as o,mt as p,wt as r,S as s};
